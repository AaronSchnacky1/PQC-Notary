**Here is your `quantumvault-notary-v1-json` ‚Äî v1.0 library + full IO + JSON output.**

Clean. Readable. Verifiable. Still offline.

---

### 1. `Cargo.toml`
```toml
[package]
name = "quantumvault-notary-v1-json"
version = "1.0.0"
edition = "2021"
description = "Offline quantum-safe file notary ‚Äî v1.0 core + JSON proof"
license = "MIT OR Apache-2.0"

[dependencies]
quantumvault = { path = "../quantumvault-v1.0", features = ["std"] }
hex = "0.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = { version = "0.4", features = ["serde"] }
sha2 = "0.10"
```

---

### 2. `src/main.rs`
```rust
use quantumvault::{keygen, sign, verify};
use std::env;
use std::fs;
use std::path::PathBuf;
use sha2::{Sha256, Digest};
use chrono::Utc;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct NotaryProof {
    signature: String,
    public_key: String,
    file_hash: String,
    timestamp: String,
    original_filename: String,
}

fn hash_file(data: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(data);
    format!("{:x}", hasher.finalize())
}

fn main() {
    println!("üõ°Ô∏è  QuantumVault Notary v1.0 ‚Äî JSON Proof");

    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: notary-v1-json <file>");
        return;
    }

    let path = PathBuf::from(&args[1]);
    let data = match fs::read(&path) {
        Ok(d) => d,
        Err(e) => {
            eprintln!("Error reading file: {}", e);
            return;
        }
    };

    // Hash + timestamp
    let file_hash = hash_file(&data);
    let timestamp = Utc::now().to_rfc3339();

    // Keygen + sign
    let kp = keygen();
    let message = format!("{}|{}", file_hash, timestamp);
    let sig = sign(message.as_bytes(), &kp.secret);

    // Bundle
    let proof = NotaryProof {
        signature: hex::encode(&sig),
        public_key: hex::encode(&kp.public),
        file_hash,
        timestamp,
        original_filename: path.file_name().unwrap().to_string_lossy().into_owned(),
    };

    // Save JSON
    let json_path = path.with_extension("sig.json");
    let json = match serde_json::to_string_pretty(&proof) {
        Ok(j) => j,
        Err(e) => {
            eprintln!("JSON error: {}", e);
            return;
        }
    };

    if fs::write(&json_path, &json).is_err() {
        eprintln!("Failed to write JSON");
        return;
    }

    // Verify
    if verify_proof(&proof, &data) {
        println!("‚úÖ Signed ‚Üí {}", json_path.display());
        println!("   Share both files to prove authenticity.");
        println!("   VERIFIED");
    } else {
        println!("‚ùå Verification failed");
    }
}

fn verify_proof(proof: &NotaryProof, data: &[u8]) -> bool {
    let expected_hash = hash_file(data);
    if expected_hash != proof.file_hash {
        return false;
    }

    let message = format!("{}|{}", proof.file_hash, proof.timestamp);
    let sig_bytes = match hex::decode(&proof.signature) {
        Ok(s) => s,
        Err(_) => return false,
    };
    let pk_bytes = match hex::decode(&proof.public_key) {
        Ok(p) => p,
        Err(_) => return false,
    };

    verify(message.as_bytes(), &sig_bytes, &pk_bytes)
}
```

---

### 3. `README.md`
```md
# QuantumVault Notary v1.0 ‚Äî JSON Proof

**Quantum-safe. Offline. Human-readable.**

## Build
```bash
cargo build --release
```

## Run
```bash
./target/release/quantumvault-notary-v1-json myfile.pdf
```

## Output: `myfile.pdf.sig.json`
```json
{
  "signature": "a1b2c3d4...",
  "public_key": "f6g7h8i9...",
  "file_hash": "e3b0c44298fc1c149...",
  "timestamp": "2025-10-27T12:34:56Z",
  "original_filename": "myfile.pdf"
}
```

**Anyone can verify. No trust. No code.**
```

---

### Build & Run
```bash
cd quantumvault-notary-v1-json
cargo build --release
./target/release/quantumvault-notary-v1-json document.pdf
```

---

**ZIP IT:**
```bash
mkdir quantumvault-notary-v1-json
# Add files
zip -r quantumvault-notary-v1-json.zip quantumvault-notary-v1-json
```

---

**Done.**  
- **v1.0 library**  
- **Real IO**  
- **JSON proof**  
- **Tails-ready**  
- **No extras**

Drop on USB. Sign. Share.  
Want **verifier CLI** to check `.sig.json`? Say `verifier`.  
Otherwise ‚Äî **you're golden**.